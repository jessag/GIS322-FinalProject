# -*- coding: utf-8 -*-
"""FinalProject_GIS322.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1p2MghIDptT176HQsKF8I_QwKeYLfmxzV
"""

!pip install geopandas # installs geopandas

import geopandas as gpd
import pandas as pd
import matplotlib.pyplot as plt

#Reading in all 50 states
states = gpd.read_file("/content/tl_2020_us_state.shp")

# View the first several records
states.head()

# Remove some territories and Hawaii/Alaska in order to see 48 contiguous only
states = states[(states.NAME != "American Samoa") & 
                (states.NAME != "Guam") & 
                (states.NAME != "United States Virgin Islands") &
                (states.NAME != "Commonwealth of the Northern Mariana Islands") &
                (states.NAME != "Puerto Rico") &
                (states.NAME != "Alaska") &
                (states.NAME != "Hawaii")]


# Ensure the proper visualization
states.plot(figsize=(20,15), color = 'lavender', edgecolor = 'navy')

type(states)

#Check projection data
states.crs

states.plot(figsize=(20,15), color = 'lavender', edgecolor = 'navy')

# Read in Povert Data (ACS 5-year Estimates)
poverty_data = pd.read_csv("/content/Poverty_Data.csv")

# Preview head of file
poverty_data.head()

# The data that is important is GEO_ID, Name, and column S1701_C03_001E
# S1701_C03_001E is the percentage of individuals in each state below poverty line.

# First, we will rename the S1701_C03_001E column to something meaningful:
poverty_data.rename(columns={'S1701_C03_001E': 'Percentage_in_Pov'}, inplace = True)

# Now, to reduce clutter remove all columns that are not 'GEO_ID', 'NAME', or 'Percentage_in_Pov'

for i in poverty_data:
  if i == ('GEO_ID'):
    print("")
  elif i == 'NAME':
    print("")
  elif i == 'Percentage_in_Pov':
      print("")
  else:
    del poverty_data[i]


# To futher clean the data, I will remove row 0, as it only provides description:
poverty_data = poverty_data.drop([0])
poverty_data = poverty_data.drop([52])

# Ensure data numeric data is of float data type
poverty_data['Percentage_in_Pov'] = poverty_data['Percentage_in_Pov'].astype(float)


# Preview head of file
poverty_data

# Read in Single_Motherhood data
motherhood_data = pd.read_csv("/content/Single_Motherhood_Data.csv")

# Preview the data
motherhood_data.head()

# The data that is important is GEO_ID, Name, and column DP02_0001E (total households),
# DP02_0011E (female householder, no spouse/partner, children under 18 years)

#Rename the prior mentioned columns to be more intuitive: 
motherhood_data.rename(columns={'DP02_0001E': 'total_households'}, inplace = True)
motherhood_data.rename(columns={'DP02_0011E': 'single_motherhood_total'}, inplace = True)

# To reduce clutter in my dataset, I will delete all unneeded data columns from DF
# needed: GEO_ID, NAME, total_households, single_motherhood_total
for i in motherhood_data:
  if i == ('single_motherhood_total'):
    print("")
  elif i == 'total_households':
    print("")
  elif i == 'GEO_ID':
      print("")
  elif i == 'NAME':
      print("")
  else:
    del motherhood_data[i]

# Preview head of file
motherhood_data.head()

# Now, there is one unneeded row of data that provides descriptions (Row 0), and
#another row for Puerto Rico that needs to be removed due to NaN value
#motherhood_data.drop([0])
motherhood_data= motherhood_data.drop([0])
motherhood_data= motherhood_data.drop([52])



# When a choropleth is produced later, it will be important to have
# normalized data. Therefore, I will be be creating a percentage by
# single_motherhood_total/total_households


#First, ensure the columns are of integer format:

motherhood_data['single_motherhood_total'] = motherhood_data['single_motherhood_total'].astype(int)
motherhood_data['total_households'] = motherhood_data['total_households'].astype(int)


# Second, create a new column
motherhood_data['sm_percentage'] = (motherhood_data['single_motherhood_total'] / motherhood_data['total_households']) * 100

motherhood_data

import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn import datasets, linear_model
import statsmodels.api as sm
from scipy import stats
# Peform the linear regression:

#Reshaping is done, because arrays must be 2D for linear regression

#Regressor:
x = np.array([motherhood_data['sm_percentage']]).reshape((-1, 1))
#Output: 
y= np.array(poverty_data['Percentage_in_Pov']).reshape((-1, 1))



#Create an instance of the class, Linear Regression
model = LinearRegression()

model.fit(x,y)


# Get the results:
# Standard form of Linear Regression Equation: y = a + bx + e

# R - Squared results
r_sq = model.score(x, y)
print("R-squared: %d percent of the variation in Y is explained by X" %(r_sq*100))


# the intercept, i.e "a"
intercept = model.intercept_
print("The intercept is: ", intercept)

# the coefficient, ie "b"
coefficient = model.coef_
print("The coefficient is: ", coefficient)


#The equation
print(" y = %f +%fx + e" %(intercept, coefficient))

#model = sm.OLS(y,x).fit()
model= sm.OLS(y, sm.add_constant(x)).fit()
model_details = model.summary()
print(model_details)

import numpy as np


fig = plt.figure(figsize = (12, 7))


#Assign values to x and y axis. X = poverty, y= single-motherhood
x = np.array(motherhood_data['sm_percentage'])
y = np.array(poverty_data['Percentage_in_Pov'])
#poverty_data['Percentage_in_Pov']

# Define y1 as the regression equation
y1 = 3.237529 +1.941318*x

#Create a scatter plot of data points
plt.scatter(x,y, color = 'black', label = 'Data point')

#Plot regression line
plt.plot(x, y1, color = 'red', label = 'Regression Line')
plt.title("Poverty & Single Motherhood Data Points with Regression Line")
plt.xlabel('Single Motherhood Rate')
plt.ylabel('Poverty Rate')

#Watermark
fig.text(0.9, 0.15, 'J. Gariepy', 
         fontsize = 10, color ='gray',
         ha ='right', va ='bottom', 
         alpha = 0.7)


# Create a legend
plt.legend()

## Attribute merge - geodatabase of states with single motherhood data. 

merged_sm_geo = pd.merge(states, motherhood_data,
                             left_on= "NAME", right_on = 'NAME')

merged_sm_geo

# Attribute merge - geodatabase of states with poverty data. 

merged_pov_geo = pd.merge(states, poverty_data,
                             left_on= "NAME", right_on = 'NAME')

#View the data
merged_pov_geo

# Import necessary Bokeh modules to enable mapping.

from bokeh.io import output_file, show, output_notebook
from bokeh.models import ColumnDataSource, ColorBar, HoverTool
from bokeh.transform import linear_cmap
from bokeh.plotting import figure
from bokeh.palettes import Spectral6 #May want to edit palette import
from bokeh.palettes import Inferno256

# Enable the notebook to display the map.
output_notebook()


# This helper function, developed by GIS 322 class staff, converts a 
# GDF into coordinates that Bokeh can utilize.

def gpd_bokeh(df):
    """Convert geometries from geopandas to bokeh format"""
    nan = float('nan')
    lons = []
    lats = []
    for i,shape in enumerate(df.geometry.values):
        if shape.geom_type == 'MultiPolygon':
            gx = []
            gy = []
            ng = len(shape.geoms) - 1
            for j,member in enumerate(shape.geoms):
                xy = np.array(list(member.exterior.coords))
                xs = xy[:,0].tolist()
                ys = xy[:,1].tolist()
                gx.extend(xs)
                gy.extend(ys)
                if j < ng:
                    gx.append(nan)
                    gy.append(nan)
            lons.append(gx)
            lats.append(gy)

        else:     
            xy = np.array(list(shape.exterior.coords))
            xs = xy[:,0].tolist()
            ys = xy[:,1].tolist()
            lons.append(xs)
            lats.append(ys) 

    return lons,lats

# Create ColumnDataSource that contains geometry and attributes of each
# state. 

# Reference: merged_sm_geo = GDF for singlemotherhood.

lons, lats = gpd_bokeh(merged_sm_geo) # Converts GPD to bokeh format
sm_source = ColumnDataSource(data=dict( #Dictionary maps coordiantes, needed attributes into CDS
    	x=lons, 
    	y=lats,
        sm_percentage = merged_sm_geo['sm_percentage'], # attribute data we're interested in 
        NAME = merged_sm_geo['NAME'])) # attribute data we're interested in

# Set up color scheme of the choropleth map using a linear_cmap

#credit: color brewer for color scheme assistance.
color_map = linear_cmap (field_name= 'sm_percentage', 
                         palette= ('#feebe2','#fbb4b9','#f768a1','#c51b8a','#7a0177'),
                         low = min(merged_sm_geo['sm_percentage']),
                         high = max(merged_sm_geo ['sm_percentage']))

# Set tools within the map
TOOLS = "pan,wheel_zoom,reset,hover,save"

# Set up components of the map

# FIGURE - Sets up map canvas, size, tools and title:
map = figure(plot_width = 800, plot_height = 600,
             title ="Single Motherhood Rates by State, 2019", 
             tools = TOOLS,)

# PATCHES = Create the individual county patches based on provided geometry data.
map.patches('x', 'y', source = sm_source, line_color = "gray", line_width=1,
            color = color_map)


# HOVERTOOL - Enable hover interactivity within the map
map.select_one(HoverTool).tooltips = [('State', '@NAME'),
                                      ('Single Motherhood Rate', '@sm_percentage%'),
                                      ]

# LEGEND - add the legend bar with the colors from color_map
color_legend= ColorBar(title ="Single Moterhood Rate",
                       orientation = 'horizontal',
                       color_mapper = color_map['transform'], width = 350, location = (-10,-10))

map.add_layout(color_legend, "below")

show(map)

#Call gpd_bokeh() function to convert GDF into format bokeh can work with.
longs, lats = gpd_bokeh(merged_pov_geo)

#Reference: merged_pov_geo 

#Create a ColumnDataSource that contains geometry and attributes information
# for each county/row of our GeoDataFrame, election_data.

poverty_data_bokeh = ColumnDataSource(data = dict( #maps values to data dictionary
                                                   x = longs,
                                                   y= lats,
                                                   NAME = merged_pov_geo["NAME"], # attribute data we're interested in
                                                   Percentage_in_Pov = merged_pov_geo ["Percentage_in_Pov"] # attribute data we're interested in
                                                   ))

#Set up color scheme of the choropleth map using a linear_cmap

color_map = linear_cmap (field_name= 'Percentage_in_Pov', 
                         palette= ('#fee5d9','#fcae91', '#fee090', '#fb6a4a', '#de2d26'),
                         low = min(merged_pov_geo['Percentage_in_Pov']),
                         high = max(merged_pov_geo ['Percentage_in_Pov']))

# Set tools within the map
TOOLS = "pan,wheel_zoom,reset,hover,save"

# Set up components of the map

# FIGURE - Sets up map canvas, size, tools and title:
map = figure(plot_width = 800, plot_height = 600,
             title ="Poverty Rate by U.S State, 2019", 
             tools = TOOLS,)

# PATCHES = Create the individual county patches based on provided geometry data.
map.patches('x', 'y', source = poverty_data_bokeh, line_color = "gray", line_width=1,
            color = color_map)


# HOVERTOOL - Enable hover interactivity within the map
map.select_one(HoverTool).tooltips = [('State', '@NAME'),
                                      ('Poverty Rate', '@Percentage_in_Pov%'),
                                      ]

# LEGEND - add the legend bar with the colors from color_map
color_legend= ColorBar(title ="Poverty Rate",
                       orientation = 'horizontal',
                       color_mapper = color_map['transform'], width = 350, location = (-10,-10))

map.add_layout(color_legend, "below")

#Display the map:
show(map)
output_file("PovertyRatesUS.html")